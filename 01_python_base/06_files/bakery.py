# 6+7+7*
# Реализовать простую систему хранения данных о суммах продаж булочной.
# Должно быть два скрипта с интерфейсом командной строки:
# для записи данных и для вывода на экран записанных данных.
#
# При записи передавать из командной строки значение суммы продаж.
#
# Для чтения данных реализовать в командной строке следующую логику:
# просто запуск скрипта — выводить все записи;
# запуск скрипта с одним параметром-числом — выводить все записи с номера,
# равного этому числу, до конца;
# запуск скрипта с двумя числами — выводить записи, начиная с номера, равного первому числу,
# по номер, равный второму числу, включительно.
#
# Подумать, как избежать чтения всего файла при реализации второго и третьего случаев.
#
# Данные хранить в файле bakery.csv в кодировке utf-8. Нумерация записей начинается с 1.
# Примеры запуска скриптов:
# python add_sale.py 5978,5
# python add_sale.py 8914,3
# python add_sale.py 7879,1
# python add_sale.py 1573,7
# python show_sales.py
# 5978,5
# 8914,3
# 7879,1
# 1573,7
# python show_sales.py 3
# 7879,1
# 1573,7
# python show_sales.py 1 3
# 5978,5
# 8914,3
# 7879,1
# Добавить возможность редактирования данных при помощи отдельного скрипта:
# передаём ему номер записи и новое значение.
# При этом файл не должен читаться целиком — обязательное требование.
# Предусмотреть ситуацию, когда пользователь вводит номер записи, которой не существует.
#
BAKERY_CSV = "resources/bakery.csv"

# Функция для добавления новой цены
def add_sale(argv):
    program, *sales = argv
    with open(BAKERY_CSV, 'a', encoding='utf-8') as f:
        f.write('{}\n'.format(sales[0]))


# Функция вывода
# Для чтения данных реализовать в командной строке следующую логику:
# просто запуск скрипта — выводить все записи;
# запуск скрипта с одним параметром-числом — выводить все записи с номера,
# равного этому числу, до конца;
# запуск скрипта с двумя числами — выводить записи, начиная с номера, равного первому числу,
# по номер, равный второму числу, включительно.
def show_sales(argv):
    program, *args = argv
    with open(BAKERY_CSV, 'r', encoding='utf-8') as f:
        if len(args) == 0:
            for line in f:
                print(line.rstrip())
        elif len(args) == 1:
            for idx, line in enumerate(f):
                if idx >= int(args[0]) - 1:
                    print(line.rstrip())
        elif len(args) == 2:
            for idx, line in enumerate(f):
                if int(args[0]) - 1 <= idx <= int(args[1]) - 1:
                    print(line.rstrip())


# Функция для изменения цены в определенной строке
# Добавить возможность редактирования данных при помощи отдельного скрипта:
# передаём ему номер записи и новое значение.
# При этом файл не должен читаться целиком — обязательное требование.
# Предусмотреть ситуацию, когда пользователь вводит номер записи, которой не существует.
def change_sale(argv):
    program, *args = argv
    idx = int(args[0])
    new_sale = args[1]

    file_map = []
    with open(BAKERY_CSV, "r", encoding='utf-8') as f:
        # составить карту файла - в формате список количества символов в строке
        # для ориентирования и проверки номера записи, которой не существует
        for line in f:
            file_map.append(len(line))

        # Выполняем проверки
        if idx > len(file_map):
            print('Товарищ, в нашем файле не существует такого номера строки для изменения')
        elif file_map[idx - 1] in {0, 1}:
            print('Друг, ты пытаешься изменить строку, в которой ничего нет')
        else:
            with open(BAKERY_CSV, "r+", encoding='utf-8') as f:
                # Определяем позицию, начиная с которой будем писать новую строку
                begin_position = 2
                for counter in range(idx - 1):
                    begin_position += file_map[counter]
                # Определяем позицию, начиная с которой нужно сохранить остаток файла и временно сохраняем его
                end_position = begin_position + file_map[idx - 1]
                f.seek(end_position)
                temp = f.read(end_position)
                # Записываем новую цену и чистим остаток файла
                f.seek(begin_position)
                f.write(new_sale)
                f.truncate()
                # Восстанавливаем конец файла
                f.write(temp)


if __name__ == '__main__':
    import sys
    exit(change_sale(sys.argv))

#  exit(add_sale(sys.argv))
#  exit(show_sales(sys.argv))
